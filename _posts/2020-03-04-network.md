---
title: "网络编程笔记"
categories:
  - Network
tags:
  - network
  - python
---

# 协议栈
协议栈又称协议堆叠。本质上是建立在底层协议的基础之上的复杂的网络服务，是协议的实现形式。可以是一个API，也可以是一个软件。

协议栈通常有很多层，每一层都会封装一些特性。例如：
- API - url - HTTP - TCP/IP套接字 - 链路层

# 数据包
网络设备间进行共享的基本单元。

# IP地址
## IPV4
由4个字节组成。每个字节的十进制数范围从0到255。通常只访问与之绑定的主机名，从主机名到IP地址的解析无需关心。

通常来说，前1-2个字节表示机构，第3个字节表示目标机器所在的特定子网，最后一个表示特定的机器或服务

一些特殊的IP地址：
- 127.\*.\*.*: 特殊的预留地址段，提供给本机的应用程序使用。通常使用127.0.0.1，表示本机。
- 10.\*.\*.\*、172.16-32.\*.\*、192.168.\*.\*: 为私有子网预留的地址段，这些地址不会分发给服务器或机构。构建内部网络时，可以随意使用。
- 广播地址：广播地址通常为该地址段的最后一个地址。计算方式为：IP地址和子网掩码按位与，再和取反的子网掩码按位或。

## IPV6

# 端口
目标机器上的应用程序对应的接口。通常在做数据发送时，要同时提供IP地址与端口号。端口号大致分为三类：
1. 0-1023 分配给最重要、最常用的服务。如http（80）、https（443）、domain（53）
2. 1024-49151 专属服务端口。被一些知名服务占用的端口。例如mysql（3369）、redis（6379）
3. 49152-65535 可以随意使用的端口。如果由操作系统来为服务随机分配端口，那么就处于这个范围之内

# 套接字
一个通信端点，实现端到端的通信。套接字由IP地址加端口号组成。应用程序进行通信时，通过套接字来收发数据。通常操作系统都会提供关于套接字的编程接口，编程语言会将其封装为一系列函数以供使用。

# UDP
IP层之上的一个传输协议。通过端口号实现了多路复用（多个信号共享信道）和多路分解。但UDP本身并不解决丢包、重包、响应地址验证等问题。

## 数据包分组
IP协议支持的数据包传输大小为64KB，但并不是所有的网络设备都支持这么大的数据包传输，所以数据包传输时，可以设置数据包分组——在数据包中不设置"DF"标记，允许分组，当数据包传输容量超过网络能接受的最大上限时，网关将其分为多个小数据包进行传输，传输结束后再重组。所以UDP容易发生丢包现象。

# TCP
## TCP实现可靠传输
- 每一个数据包都有一个序列号seq，接收方通过序列号将数据包正确排序，如果有数据包丢失，就会请求重传。
- 初始序列号是随机的，所以无法被解析。后续的序列号等于上一个数据包的序列号+数据字节大小。
- TCP数据包之间的发送无需阻塞等待，在某一时刻发送方希望同时传输的数据量叫*TCP窗口*大小。
- 接收方可以实现*流量控制*：控制发送方的窗口大小，在缓冲区已满时禁止传输数据。
- TCP在丢包后会减少每秒发送的数据量。

## 缓冲区
网络连接中的每一端的TCP栈都有缓冲区，用于暂存数据，当数据没有被及时接收，也不会丢弃并重发这些数据。缓冲区的大小视操作系统而定。

## 三次握手
建立连接的方式：
- SYN: 客户端发送的数据包的初始随机序列号
- SYN-ACK: 服务端回复
- ACK: 客户端回复

## 四次挥手
断开连接的方式，可以是4次：
1. 客户端发送FIN请求关闭，此时客户端处于请求等待状态（FIN-WAIT）。
2. 服务端接收FIN，发送ACK回复。此时服务端处于关闭等待状态（CLOSE-WAIT）。
3. 客户端接收ACK。此时客户端处于半连接状态（FIN-WAIT）。
4. 服务端发送FIN请求关闭，此时服务端处于最后回复状态（FIN-WAIT）。
5. 客户端接收FIN，然后发送ACK，然后客户端处于等待状态（TIME-WAIT）。
6. 服务端接收ACK，进入关闭状态(CLOSED)。
7. 客户端在等待2MSL后，进入关闭状态（CLOSED）。

也可以是3次：如果服务端在接收到FIN请求后，没有数据要发送给客户端了，那么服务端可以将FIN和ACK同时发送给客户端，客户端跳过请求等待状态，直接发送ACK，进入TIME-WAIT状态。

### TIME-WAIT
网络传输有丢包的现象，如果最后一次客户端发送的ACK丢失了，服务端会重复FIN请求。所以客户端必须要等待2MSL，以确定服务端收到了ACK，如果等待ACK丢失，那么服务端重复FIN请求，客户端还可以重发ACK回复。

MSL是TCP报文的最大存活时间，2MSL可以确保两个传输方向的报文正确到达。

### 通信死锁
TCP数据包的传输会存放在接收方的缓冲区内，当缓冲区被填满，流量控制就会生效，禁止发送方继续发送数据，直到缓冲区内的数据被处理。但是如果此时发送方的缓冲区也被占满，就会导致死锁。

如何避免死锁？  
关闭阻塞。当调用发送接口或接收接口时发现还不能接收发送数据时就会立刻返回。

使用多线程或多进程处理。