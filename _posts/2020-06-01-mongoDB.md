---
title: "pymongo使用笔记"
categories:
  - MongoDB
  - DataBase
tags:
  - MongoDB
  - pymongo
---

# 数据库连接
## 使用pymongo连接
```python
import pymongo

mongourl = f'mongodb://username:password@localhost:27017'
myclient = pymongo.MongoClient(mongo_url)
db = myclient[database]   # 获取数据库
collection = db.get_collection(collection_name) # 获取集合
```

## 在shell中连接mongoDB
```shell
// 连接本地mongodb
> mongo

// 连接远程mongodb
> mongo 192.168.188.14:27018/admin -u root -p epochn

// 如果无法连接可以尝试加入参数
> mongo --authenticationDatabase 192.168.188.14:27018/admin -u root -p epochn
```

# 查看mongoDB状态
在shell中
```shell
> db.collection.stats()
```

在pymongo中
```python
db.command('collstats', collection)   # 集合状态
db.command('dbstats')   # 数据库状态
```

# 常用方法
```python
db.list_collection_names(session=None)
collection.list_indexes()       # 查看集合所有索引
collection.index_infomation()   # 查看索引信息
```

# CRUD
## 查询
### 查询多条数据
```python
res = collection.find(options, extra)
```

### 查询单条数据
```python
res = collection.find_one(options, extra)
```

### 空值
```python
collection.find({'field': None})
collection.find({'field': ""})
collection.find({'field': {'$exists': False}})
```

注意，三种查询空值的方式所得到的结果是不同的，所以要么统一空值的表示，要么使用高级查询的`unwind`

### 嵌套查询
假设一个拥有嵌套文档结构的集合：
```python
[
  {
    "name": "col1",
    "data": [
      {"score": 12, "pos": 1},
      {"score": 23, "pos": 32}
    ]
  }
]
```
查询`score`大于15的数据
```python
res = collection.find({"data.score": {"$gt": 15}})
```

### 数组过滤（elemMatch）
假设一个集合拥有字段
```python
[
  {
    "name": "col",
    "tags": [
      {"value": 't1', "id": 13},
      {"value": "t2", "id": 11}
    ]
  },
  {
    "name": "col2",
    "tags": [
      {"value": 't11', "id": 15},
      {"value": "t21", "id": 21}
    ]
  },
]
```
现在我想查询`tags`字段下的`value`为`t1`，并且`id`为`15`的数据。可以很快的想到使用嵌套查询。
```python
res = collection.find({'tags.value': 't1', 'tags.id':15})
```

理论上应该查询不到任何数据，因为我们期待`value`和`id`存在于同一个字典中，或者说，我们期待查询的元素是数组中的一个元素。

但事实上，`value`和`id`并不是保存在同一个地址下的。所以它会匹配全集合中满足其中一个条件的数据并返回。可以说，对于数组的查询，只需满足其中一个元素便可以看作查询匹配。

我们可以使用`elemMatch`限制。`elemMatch`会匹配包含一个数组字段的文档，该数组字段中至少要有一个元素与查询条件匹配，所以理论上如果你的查询条件只有一个，那就不需要使用`elemMatch`
```python
res = collection.find(
  {'tags.value': 't1', 'tags.id': 15},
  {'tags': {
    {'$elemMatch': {'tags.value': 't1', 'tags.id': 15}}
  }}
)
```
当查询不到任何与之匹配的`tags`时，以上的查询语句只会返回`_id`

## 修改
### 修改单条
```python
res = collection.update_one(options, data)
res.modified_count
```

### 修改多条
```python
res = collection.update_many(options, data)
res.modified_count
```

### 查询并修改
```python
res = collection.find_one_and_update(options, data, return_document=pymongo.ReturnDocument.BEFORE)

# res表示修改前的数据
```

### 查找并替换
```python
res = collection.find_one_and_replace(options, data, return_docuemnt=pymongo.ReturnDocument.AFTER)
```

与设置某一字段不同，替换的`data`将会把旧数据完全覆盖。

### 删除字段
```python
res = collection.update_many(options, {'$unset': {field: None}})
```

### 嵌套文档的修改
假设一个拥有嵌套文档结构的集合
```python
[
  {
    "name": 'col',
    'data': [
      {'value': 't1', 'pos': 12},
      {'value': 't2', 'pos': 13},
      {'value': 't21', 'pos': 13},
    ]
  }
]
```
我们想修改`pos`为13的`value`。可以这样写
```python
res = collection.update_many(
  {'data.pos': 13},
  {'$set': {
    'data.$.value': 'modt121'
  }}
)
```

# 高级查询
## 管道
### match
### group
### project
### addFields
### lookup
### set
### unwind
### count
### limit

## 管道运算
### add
### addToSet
### ceil
### concat
### cond
### filter
### ifNull
### map
### mergeObjects
### reduce
### substr
### toString
### toInt